// Mon Apr 27 16:03:16 PDT 2020
// bison syntax indicating C++ declarations required by both the parser and scanner

%code requires {
  #include <string>
  class Expression;
  class Variable;
  struct Parameter;
  class Statement;
  #include "Variable.h"
  #include "Constant.h"
  #include "Scope_manager.h"
  #include <cassert>
  #ifndef P1
    #include "types_and_ops.h"  //include in all projects except the first
  #endif
  #ifdef GRAPHICS
    #include "Window.h"
  #endif
}

// bison syntax to indicate the beginning of a C/C++ code section
%{

extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l



#include "error.h"      // class for printing errors (used by gpl)
#include <iostream>

// bison syntax indicating the end of a C/C++ code section
%}


// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 int            union_int;
 std::string*   union_string;  // MUST be a pointer to a string
 double         union_double;
 GPL::Type      union_gpl_type;
 Constant*      union_constant_ptr;
 const Expression* union_expression_ptr;
 Variable*      union_variable_ptr;
 const Game_object* union_game_object_ptr;
};
%destructor { delete $$; } <union_string>

// tokens declared here
%token <union_gpl_type> T_INT             "int"
%token <union_gpl_type> T_DOUBLE           "double"
%token <union_gpl_type> T_STRING          "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token T_FORWARD             "forward"
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_EXIT            "exit"  /* value is line number */
%token <union_string> T_PRINT           "print"  /* value is line number */
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"

%token <union_int> T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token <union_string> T_ID            	 "identifier"

 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"
%type <union_gpl_type> simple_type;
%type <union_expression_ptr> expression;
%type <union_expression_ptr> optional_initializer;
%type <union_expression_ptr> primary_expression;
%type <union_variable_ptr> variable;
%type <union_game_object_ptr> object_declaration;
%type <union_gpl_type> object_type;
%type <union_game_object_ptr> T_CIRCLE;
%type <union_game_object_ptr> T_PIXMAP;
%type <union_game_object_ptr> T_RECTANGLE;
%type <union_game_object_ptr> T_TEXTBOX;
%type <union_game_object_ptr> T_TRIANGLE;

%left T_OR
%left T_AND
%left  T_EQUAL T_NOT_EQUAL
%left T_LESS T_GREATER T_LESS_EQUAL T_GREATER_EQUAL
%left T_PLUS T_MINUS
%left T_MULTIPLY T_DIVIDE T_MOD

%nonassoc T_NEAR
%nonassoc T_TOUCHES
%nonassoc T_NOT
%nonassoc UNARY_OPS

%token T_IF_NO_ELSE

%nonassoc T_IF_NO_ELSE
%nonassoc T_ELSE


%%

// updated October 2021

//---------------------------------------------------------------------
program:
    declaration_list block_list


//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | %empty


//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC


//---------------------------------------------------------------------
variable_declaration:
    simple_type  T_ID optional_initializer
    {
      Scope_manager& scopeman=Scope_manager::instance();
      if(scopeman.defined_in_current_scope(*$2))
      {
        Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
        // break after error because bison-generated code
        // embeds each rule in a case of a switch statement
        delete $2;
        delete $3;
        break;
      }
      int* int_ptr;
      double* double_ptr;
      std::string* str_ptr;
      bool is_good = true;
      const Constant* c;
      if($3 != nullptr)
      {
        c = $3->evaluate();
        switch($1)
        {
          case GPL::INT:
            try
            {
              if(GPL::INT != $3->type())
              {
                is_good = false;
                throw(is_good);
              }
            }
            catch(bool b)
            {
              Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, to_string($3->type()), *$2, to_string(GPL::INT));
            }
            if(!is_good)
            {
              int_ptr = new int(0);
              scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, int_ptr));
              break;
            }
            int_ptr = new int(c->as_int());
            scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, int_ptr));
            break;
          case GPL::DOUBLE:
          {
            try
            {
              if(GPL::STRING == $3->type())
              {
                is_good = false;
                throw(is_good);
              }
            }
            catch(bool b)
            {
              Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, to_string($3->type()), *$2, to_string(GPL::DOUBLE));
            }
            if(!is_good)
            {
              double_ptr = new double(0.0);
              scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, double_ptr));
              break;
            }
            double_ptr = new double(c->as_double());
            scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, double_ptr));
            break;
          }
          case GPL::STRING:
          {
            str_ptr = new std::string(c->as_string());
            scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, str_ptr));
            break;
          }
          default:
            assert(false);
        }
        //delete c;
      }
      else
      {
        switch($1)
        {
          case GPL::INT:
            int_ptr = new int(0);
            scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, int_ptr));
            break;
          case GPL::DOUBLE:
            double_ptr = new double(0.0);
            scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, double_ptr));
            break;
          case GPL::STRING:
            str_ptr = new std::string(     ($3==nullptr) ?  "" : c->as_string()    );
            scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, str_ptr));
            break;
          default:
            assert(false);
        }
      }
      delete $2;
      delete $3;
    }
    | simple_type  T_ID T_LBRACKET expression T_RBRACKET
    {
      Scope_manager& scopeman=Scope_manager::instance();
      GPL::Type t = $4->type();
      const Constant* c = $4->evaluate();
      bool b = scopeman.defined_in_current_scope(*$2);
      bool create = false;
      if(t != GPL::INT)
      {
        Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, to_string(t), *$2);
        int* temp_i = new int[1];
        temp_i[0] = 0;
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, temp_i, 1));
        delete $4;
        delete $2;
        break;
      }
      int num = c->as_int();
      if(num < 1)
      {
        std::string temp = std::to_string(num);
        Error::error(Error::INVALID_ARRAY_SIZE,*$2,temp);
        create = true;
      }
      if(b)
      {
        Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
      }
      if(create && !b)
      {
        int* temp_i = new int[1];
        temp_i[0] = 0;
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, temp_i, 1));
      }
      if(create || b)
      {
        delete $2;
        delete $4;
        break;
      }
      if($1 == GPL::INT)
      {
        int* temp_i = new int[num];
        for(int i = 0; i < num; i++)
        {
          temp_i[i] = 0;
        }
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, temp_i, num));
      }
      else if($1 == GPL::DOUBLE)
      {
        double* temp_d = new double[num];
        for(int i = 0; i < num; i++)
        {
          temp_d[i] = 0.0;
        }
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, temp_d, num));
      }
      else if($1 == GPL::STRING)
      {
        std::string* temp_s = new std::string[num];
        for(int i = 0; i < num; i++)
        {
          temp_s[i] = "";
        }
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, temp_s, num));
      }
      else
      {
        assert(false);
      }
      delete $2;
      delete $4;
    }



//---------------------------------------------------------------------
simple_type:
    T_INT        {$$=GPL::INT;}
    | T_DOUBLE   {$$=GPL::DOUBLE;}
    | T_STRING   {$$=GPL::STRING;}


//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression {$$=$2;}
    | %empty {$$=nullptr;}


//---------------------------------------------------------------------
object_declaration:
  object_type T_ID parameter_list_or_empty
  {
    Scope_manager& scopeman=Scope_manager::instance();
    if(scopeman.defined_in_current_scope(*$2))
    {
      Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
      // break after error because bison-generated code
      // embeds each rule in a case of a switch statement
      delete $2;
      break;
    }
    if($1 == GPL::CIRCLE)
    {
      Circle* circ_ptr = new Circle();
      scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,circ_ptr));
    }
    else if($1 == GPL::PIXMAP)
    {
      Pixmap* pix_ptr = new Pixmap();
      scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,pix_ptr));
    }
    else if($1 == GPL::RECTANGLE)
    {
      Rectangle* rect_ptr = new Rectangle();
      scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,rect_ptr));
    }
    else if($1 == GPL::TEXTBOX)
    {
      Textbox* text_ptr = new Textbox();
      scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,text_ptr));
    }
    else if($1 == GPL::TRIANGLE)
    {
      Triangle* tri_ptr = new Triangle();
      scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,tri_ptr));
    }
  }
  | object_type T_ID T_LBRACKET expression T_RBRACKET
    {
      Scope_manager& scopeman=Scope_manager::instance();
      const Constant* c = $4->evaluate();
      bool in_scope = scopeman.defined_in_current_scope(*$2);
      bool create = false;
      if($4->type() != GPL::INT)
      {
        Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, to_string($4->type()), *$2);
        Circle* temp_obj = new Circle[1];
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, temp_obj, 1));
        delete $4;
        delete $2;
        break;
      }
      int num = c->as_int();
      if(num < 1)
      {
        std::string temp = std::to_string(num);
        Error::error(Error::INVALID_ARRAY_SIZE,*$2,temp);
        create = true;
      }
      if(in_scope)
      {
        Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
      }
      if(create && !in_scope)
      {
        Circle* temp_obj = new Circle[1];
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2, temp_obj, 1));
      }
      if(create || in_scope)
      {
        delete $2;
        delete $4;
        break;
      }
      if($1 == GPL::CIRCLE)
      {
        Circle* circ_ptr = new Circle[num];
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,circ_ptr,num));
      }
      else if($1 == GPL::PIXMAP)
      {
        Pixmap* pix_ptr = new Pixmap[num];
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,pix_ptr,num));
      }
      else if($1 == GPL::RECTANGLE)
      {
        Rectangle* rect_ptr = new Rectangle[num];
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,rect_ptr,num));
      }
      else if($1 == GPL::TEXTBOX)
      {
        Textbox* text_ptr = new Textbox[num];
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,text_ptr,num));
      }
      else if($1 == GPL::TRIANGLE)
      {
        Triangle* tri_ptr = new Triangle[num];
        scopeman.add_to_current_scope(std::make_shared<Symbol>(*$2,tri_ptr,num));
      }
    }


//---------------------------------------------------------------------
object_type:
    T_TRIANGLE        {$$=GPL::TRIANGLE;}
    | T_PIXMAP        {$$=GPL::PIXMAP;}
    | T_CIRCLE        {$$=GPL::CIRCLE;}
    | T_RECTANGLE     {$$=GPL::RECTANGLE;}
    | T_TEXTBOX       {$$=GPL::TEXTBOX;}


//---------------------------------------------------------------------
parameter_list_or_empty :
    T_LPAREN parameter_list T_RPAREN
    | T_LPAREN T_RPAREN
    | %empty


//---------------------------------------------------------------------
parameter_list :
    parameter_list T_COMMA parameter
    | parameter


//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression


//---------------------------------------------------------------------
block_list:
    block_list block
    | %empty


//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block


//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block


//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block


//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN {$3=$3;}


//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID {$2=$2;}
    | object_type


//---------------------------------------------------------------------
animation_block:
    animation_declaration statement_block


//---------------------------------------------------------------------
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN {$2=$2; $5=$5;}


//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block


//---------------------------------------------------------------------
keystroke:
    T_SPACE
    | T_UPARROW
    | T_DOWNARROW
    | T_LEFTARROW
    | T_RIGHTARROW
    | T_LEFTMOUSE_DOWN
    | T_MIDDLEMOUSE_DOWN
    | T_RIGHTMOUSE_DOWN
    | T_LEFTMOUSE_UP
    | T_MIDDLEMOUSE_UP
    | T_RIGHTMOUSE_UP
    | T_MOUSE_MOVE
    | T_MOUSE_DRAG
    | T_AKEY
    | T_SKEY
    | T_DKEY
    | T_FKEY
    | T_HKEY
    | T_JKEY
    | T_KKEY
    | T_LKEY
    | T_WKEY
    | T_ZKEY
    | T_F1


//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block
    | statement


//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE
    | T_LBRACE T_RBRACE



//---------------------------------------------------------------------
statement_list:
    statement_list statement
    | statement


//---------------------------------------------------------------------
statement:
    if_statement
    | for_statement
    | assign_statement T_SEMIC
    | print_statement T_SEMIC
    | exit_statement T_SEMIC


//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec T_IF_NO_ELSE
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements

//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements


//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN


//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN


//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement
    | %empty


//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression
    | variable T_PLUS_ASSIGN expression
    | variable T_MINUS_ASSIGN expression
    | variable T_PLUS_PLUS
    | variable T_MINUS_MINUS


//---------------------------------------------------------------------
variable:
    T_ID { $$ = new Variable(*$1); delete $1; }
    | T_ID T_LBRACKET expression T_RBRACKET { $$ = new Variable(*$1, $3); delete $1;}
    | T_ID T_PERIOD T_ID {$3=$3; $1=$1;}
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID {$6=$6; $1=$1;}


//---------------------------------------------------------------------
expression:
    primary_expression {$$=$1;}
    | expression T_OR expression
      {
        bool has_string = false;
        if($1->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "||");
          has_string = true;
        }
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "||");
          has_string = true;
        }
        if(has_string)
        {
          delete $1;
          delete $3;
          $1 = new Integer_constant(0);
          $3 = new Integer_constant(0);
        }
        $$=new Or($1, $3);
      }
    | expression T_AND expression
      {
        bool has_string = false;
        if($1->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "&&");
          has_string = true;
        }
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "&&");
          has_string = true;
        }
        if(has_string)
        {
          delete $1;
          delete $3;
          $1 = new Integer_constant(0);
          $3 = new Integer_constant(0);
        }
        $$=new And($1, $3);
      }
    | expression T_LESS_EQUAL expression {$$=new Less_Equal($1,$3);}
    | expression T_GREATER_EQUAL  expression {$$=new Greater_Equal($1,$3);}
    | expression T_LESS expression {$$=new Less($1,$3);}
    | expression T_GREATER  expression {$$=new Greater($1,$3);}
    | expression T_EQUAL expression {$$=new Equal($1,$3);}
    | expression T_NOT_EQUAL expression {$$=new Not_Equal($1,$3);}
    | expression T_PLUS expression { $$=new Plus($1, $3);}
    | expression T_MINUS expression
      {
        bool has_string = false;
        if($1->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "-");
          has_string = true;
        }
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "-");
          has_string = true;
        }
        if(has_string)
        {
          delete $1;
          delete $3;
          $1 = new Integer_constant(0);
          $3 = new Integer_constant(0);
        }
        $$=new Minus($1, $3);
      }
    | expression T_MULTIPLY expression
      {
        bool has_string = false;
        if($1->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "*");
          has_string = true;
        }
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "*");
          has_string = true;
        }
        if(has_string)
        {
          delete $1;
          delete $3;
          $1 = new Integer_constant(0);
          $3 = new Integer_constant(0);
        }
        $$=new Multiply($1, $3);
      }
    | expression T_DIVIDE expression
      {
        bool has_string = false;
        if($1->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "/");
          has_string = true;
        }
        if($3->evaluate()->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "/");
          has_string = true;
        }
        if(has_string)
        {
          delete $1;
          delete $3;
          $1 = new Integer_constant(1);
          $3 = new Integer_constant(1);
        }
        $$=new Divide($1, $3);
      }
    | expression T_MOD expression
      {
        bool not_int = false;
        if($1->type() != GPL::INT)
        {
          Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "%");
          not_int = true;
        }
        if($3->type() != GPL::INT)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "%");
          not_int = true;
        }
        if(not_int)
        {
          delete $1;
          delete $3;
          $1 = new Integer_constant(1);
          $3 = new Integer_constant(1);
        }
        $$=new Mod($1, $3);
      }
    | T_MINUS  expression %prec UNARY_OPS
      {
        bool not_num = false;
        if($2->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "-");
          not_num = true;
        }
        if(not_num)
        {
          delete $2;
          $2 = new Integer_constant(1);
        }
        $$=new Neg($2);
      }
    | T_NOT  expression
      {
        bool not_num = false;
        if($2->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "!");
          not_num = true;
        }
        if(not_num)
        {
          delete $2;
          $2 = new Integer_constant(1);
        }
        $$=new Not($2);
      }
    | expression T_NEAR expression {$$=nullptr; /*CHANGE*/}
    | expression T_TOUCHES expression {$$=nullptr; /*CHANGE*/}


primary_expression:
    T_SIN T_LPAREN expression T_RPAREN
    {
      if($3->type() == GPL::STRING)
      {
        Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "sin");
        delete $3;
        $$=new Integer_constant(0);
        break;
      }
      $$=new Sin($3);
    }
    | T_COS T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "cos");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Cos($3);
      }
    | T_TAN T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "tan");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Tan($3);
      }
    | T_ASIN T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "asin");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Asin($3);
      }
    | T_ACOS T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "acos");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Acos($3);
      }
    | T_ATAN T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "atan");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Atan($3);
      }
    | T_SQRT T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "sqrt");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Sqrt($3);
      }
    | T_ABS T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "abs");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Abs($3);
      }
    | T_FLOOR T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "floor");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Floor($3);
      }
    | T_RANDOM T_LPAREN expression T_RPAREN
      {
        if($3->type() == GPL::STRING)
        {
          Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "random");
          delete $3;
          $$=new Integer_constant(0);
          break;
        }
        $$=new Random($3);
      }


//---------------------------------------------------------------------
primary_expression:
    T_LPAREN  expression T_RPAREN {$$=$2;}
    | variable {$$=$1;}
    | T_INT_CONSTANT { $$=new Integer_constant($1);}
    | T_TRUE {$$=new Integer_constant(1);}
    | T_FALSE {$$=new Integer_constant(0);}
    | T_DOUBLE_CONSTANT{ $$=new Double_constant($1);}
    | T_STRING_CONSTANT { $$=new String_constant(*$1); delete $1;}


%%
